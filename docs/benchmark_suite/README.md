# A rapid review, comparison, and benchmark suite of system-level provenance tools for practical use

## Background

The Oxford English Dictionary defines _provenance_ as "a record of the ultimate origin and passage of an item through its previous owners."
In the domain of computational science, we will specialize this definition to mean "the computational input artifacts and computational processes that influenced a certain computational output artifact", as described by Freire [@freireProvenanceComputationalTasks2008].
This definition is usually applied recursively, so the computational provenance would describe the output, the inputs, the inputs' inputs, and so forth until the artifacts were generated outside the computational system (they could be generated by an opaque computational system or directly by a user).
[DSK: perhaps better "the artifacts come from outside the computational system, such as observations"?]

Computational provenance has many potential applications, including the following [@pimentelSurveyCollectingManaging2019]:
1. **Caching**. A black-box system that captures provenance knows what inputs affect the output for each process, so it knows which processes to re-execute without a user-supplied dependency graph programmer, as in traditional Make. [DSK: I think of caching as knowing what not to re-execute, aka memoization. What you describe here is more checkpointing to me. They are related...]
2. **Comprehension**. Provenance data helps the user understand, debug, and document workflows.
3. **Management**. Provenance data can help catalog, label, and recall experimental results based on the input parameters.
4. **Reproducibility**. A description of the inputs and processes used to generate a specific output can aid manual and automatic reproduction of that output[^"Reproduction", in the ACM sense, where a **different team** uses the **same artifacts** to generate the output artifact [@acminc.staffArtifactReviewBadging2020].].

One can capture computational provenance by modifying an application to report provenance data, leveraging a workflow engine or programming language to report provenance data, or leveraging an operating system to emit provenance data to report provenance data [@freireProvenanceComputationalTasks2008].
- **Application-level** provenance is the most semantically rich, since it knows the use of each input at the application-level (see @fig:app-lvl-prov), but the least general, since each application would have to be modified individually.
- **Workflow-level** or **language-level** provenance is a middle ground in semantic richness and generality;
  it only knows the use of inputs in a dataflow sense (see @fig:wf-lvl-prov), but all applications using the provenance-modified workflow engine or programming language would emit provenance data without themselves being modified to emit provenance data.
- **System-level** is the most general, since all applications on the system would emit provenance data, but it is the least semantically rich, since observed dependencies may overapproximate the true dependencies (see [@fig:sys-lvl-log; @fig:sys-lvl-prov]).

<div id="fig:prov">

``` {#fig:app-lvl-prov caption="Application-level prov" width=24%}
digraph {
  A [label="L img"];
  B [label="R img"];
  C [label="L blur"];
  D [label="R blur"];
  E [label="stereo map"];
  A -> C [label="gaus blur"];
  B -> D [label="gaus blur"];
  {C, D} -> E [label="align"];
}
```

``` {#fig:wf-lvl-prov caption="Workflow-level prov" width=24%}
digraph {
  A -> B [label="X"];
  C -> D [label="X"];
  {B, D} -> E [label="Y"];
}
```

```{#fig:sys-lvl-log caption="Sys-level log" width=24%}
read A
write B
read C
write D
write E


```{#fig:sys-lvl-prov caption="Sys-level prov" width=24%}
digraph {
  A -> B;
  {A, C} -> {D, E};
}
```

Several provenance graphs collected at different levels.

</div>

## Motivation

Lack of reproducibility in computational experiments undermines the long-term credibility of science and hinders the day-to-day work of researchers.
Empirical studies [@trisovicLargescaleStudyResearch2022; @graysonAutomaticReproductionWorkflows2023; @collbergRepeatabilityComputerSystems2016; @zhaoWhyWorkflowsBreak2012] show that reproducibility is rarely achieved in practice, probably due to its difficulty under the short time constraints that scientists have for new publications.^[DSK: also due to a lack of incentives for achieving it, at least in comparison to other things that could be done with the same effort.]
Rather than exhorting researchers to spend more of their short time-budget on reproducibility, it may be more effective to make reproducibility easier to achieve with the same amount of effort.

Provenance data improves manual reproducibility, because users have a record of the inputs, outputs, and processes used to create a computational artifact.
Provenance data also has the potential to enable automatic reproducibility, if the process trace is detailed enough to be "re-executed".

One may imagine an abstract tradeoff curve between "enabling provenance applications such as reproducibility" as the horizontal axis increasing rightwards and "cost to implement" that provenance data on the vertical axis increasing upwards (fig. [@fig:cost-vs-enabling]).
A typical status quo, not collecting any provenance data and not using workflows, is at the bottom left:
  no added cost and does nothing to enable provenance applications.
System-level, workflow/language-level, and application-level are on a curve, increasing cost and enabling more provenance applications.

The initial jump in cost from nothing to system-level may be low because the user need not change _anything_ about their application;
  they merely need to install some provenance tracer onto their system and run their code, without modifying it, in the tracer.
Perceived ease of use is a critical factor in the adoption of new technologies (formalized in the Technology Acceptance Model [@davisTechnologyAcceptanceModel1985]).
Although the user may eventually use more semantically rich provenance, low-cost system-level provenance would get provenance's "foot in the door".
While this data is less rich than that of the workflow or application level, it may be enough to enable important applications such as caching, reproducibility, and file-level comprehension.
Since system-level provenance collection is a possibly valuable tradeoff between cost and enabling provenance applications, system-level provenance will be the subject of this work.

## Contributions

This work aims to summarize state of the art, establish goalposts for future research in the area, and identify which provenance tools are practically usable.

This work contributes:
- **A rapid review**:
    There are a scores of academic publications on system-level provenance (see @tbl:tools), so we collate all of prior provenance tools and classify them by _capture method_ (e.g., does the provenance collector require you to load a kernel module or run your code in a VM?). 
- **A benchmark suite**:
  Prior work does not use a consistent set of benchmarks; often publications use an overlapping set of benchmarks from prior work <!-- TODO: ref table -->.
  We collate benchmarks used in prior work, add some unrepresented areas, and find a statistically valid subset of the benchmark.
- **A quantitative performance comparison**:
  Prior publications often only compares the performance their provenance tool to the baseline, no-provenance performance, not to other provenance tools.
  It is difficult to compare provenance tools, given data of different benchmarks on different machines.
  This work runs a consistent set of benchmarks on a single machine over all provenance tools.
- **A predictive performance model**:
  The performance overhead of a single provenance system vary from <1% to 23% [@muniswamy-reddyLayeringProvenanceSystems2009] based on the application, so a single number for overhead is not sufficient.
  This work develops a statistical model for predicting the overhead of \$X application in \$Y provenance system based on \$Y provenance system's performance on our benchmark suite and \$X application's performance characteristics (e.g., number of I/O syscalls).

## Methods

### Rapid review

We began a rapid review to identify the research state-of-the-art tools for automatic system-level provenance.

Rapid Reviews are a lighter-weight alternative to systematic literature reviews with a focus on timely feedback for decision-making.
@schunemann_reviews_2015 show that Rapid Reviews can yield substantially similar results to a systematic literature review, albeit with less detail.
Although developed in medicine, Cartaxo et al. show that Rapid Reviews are useful for informing software engineering design decisions [@cartaxo_role_2018; @cartaxo_rapid_2020].

We conducted a rapid review with the following parameters:

- **Objective**: Identify system-level provenance collection tools.
- **Search terms**: "system-level" AND "provenance"
- **Search engine**: Google Scholar
- **Number of results**: 50
  - This threshold is the point of diminishing returns, as no new tools came up in the 40th â€“ 50th results.
- **Criteria**: A relevant publication would center on one or more operating system-level tools that capture file provenance. A tool requiring that the user use a specific application or platform would be irrelevant.

We record the following features for each system-level provenance tool:

- **Capture method**: What method does the tool use to capture provenance?
  - **User-level tracing**:
    A provenance tool may use "debugging" or "tracing" features provided by the kernel to trace the I/O operations of another program, e.g., `ptrace(2)` [@Ptrace].
  - **Builtin auditing service**:
    A provenance tool may use auditing service built in to the kernel, e.g., Linux Auditing Framework [@madabhushanaConfigureLinuxSystem2021], enhanced Berkeley Packet Filter (eBPF) [@BPFDocumentation], kprobes [@kenistonKernelProbesKprobes], and ETW [@EventTracingWin322021] for Windows.
  - **Filesystem instrumentation**:
    A provenance tool may set up a file system, so it can log I/O operations, e.g., using Filesystem in User SpacE (FUSE) interface [@FUSE], or Virtual File System (VFS) interface [@goochOverviewLinuxVirtual].
  - **Dynamic library instrumentation**:
    A provenance tool may replace a library used to execute I/O operations (e.g., glibc) with one that logs the calls before executing them.
  - **Binary instrumentation**:
    A provenance tool may use binary instrumentation (dynamic or static) to identify I/O operations in another program.
  - **Compile-time instrumentation**:
    A provenance tool may be a compiler pass that modifies the program to emit provenance data, especially intra-program control flow.
  - **Kernel instrumentation**:
    A provenance tool may be a modified kernel either by directly modifying the kernel's source tree or loading a kernel module.
  - **VM instrumentation**:
    A provenance tool may execute the program in a virtual machine, where it can observe the program's I/O operations.
- **Is source code available?**:
  We use the categorical codes given by @collbergRepeatabilityComputerSystems2016 to describe whether the source code is in the article, found on the web, found by an email from the author, refused from an email by the author, or the authors did not reply.

### Selecting benchmarks

Using the tools selected above, we identify all benchmarks that have been used in prior work.
<!-- TODO: Explain methodology for selecting/implementing benchmark -->
To get consistent measurements, we select as many benchmarks and provenance tracers as we reasonably can, and run a complete matrix (every tracer on every benchmark).

We also added new benchmarks:
- **Workflows**:
  Only one of the commonly used benchmarks from prior work (BLAST) resembles an e-science workflow (multiple intermediate inputs/outputs on the filesystem), so we added non-containerized Snakemake workflows from prior work [@graysonAutomaticReproductionWorkflows2023].
- **Data science**:
  None of the benchmarks resembled a typical data science program, so we added the most popular Notebooks from Kaggle.com, a data science competition website.
- **Compilations**:
  Prior work uses compilation of Apache or of Linux.
  We added compilation of several other packages (any package in Spack) to our benchmark.
  Compiling packages is a good use-case for a provenance tracer, because a user might trial-and-error multiple compile commands and not remember the exact sequence of "correct" commands;
  the provenance tracker would be able to recall the commands which did not get overwritten, so the user can know what commands "actually worked". ^[DSK: this reminds me of VisTrails from Utah]

In order to reduce the amount of work needed to reduce the amount of time it takes for the now numerous benchmarks to run for future work, we implement a subsetting procedure based on Yi's methodology (vectorization $\to$ standardization $\to$ PCA $\to$ hierarchical clustering) [@yiEvaluatingBenchmarkSubsetting2006a], such that the resulting subset contains almost as much predictive information as the full set.

### Quantitative performance comparison

We use BenchExec [@beyerReliableBenchmarkingRequirements2019] to precisely measure the CPU time, wall time, memory utilization, and other attributes of the process (including child processes) in a Linux CGroup without networking, isolated from other processes on the system.

### Predictive performnace model

## Results

### Qualitative feature comparison

@tbl:tools shows the provenance tools we collected and their qualitative features, while @tbl:excluded shows the tools which have been called "system-level provenance tools" but do not fit the definition used in this paper.
Of these, @tbl:prior-benchmarks shows the benchmarks used to evaluate each tool.
Running HTTP servers may be a popular benchmark because prior work focuses overwhelmingly on provenance for the sake of security (auditing, intrusion detection, or digital forensics);
  securing HTTP servers and web applications is a common task.

| Tool                                                           | Collection method                       | Collection tool                               | Notes                                                         |
+----------------------------------------------------------------+-----------------------------------------+-----------------------------------------------+---------------------------------------------------------------+
| SPADE [@gehaniSPADESupportProvenance2012]                      | Audit, FS, **or** compile-time           | Multiple[^spade]                           | Can use multiple low-level sources                          |
| OPUS [@balakrishnanOPUSLightweightSystem2013]                  | Library instrumentation                  | libc instrumentaiton                       |                                                             |
| FiPS [@sultanaFileProvenanceSystem2013]                        | FS. ins.                                 | VFS                                        |                                                             |
| RecProv [@jiRecProvProvenanceAwareUser2016]                    | Tracing                                  | rr, ptrace                                 |                                                             |
| PANDDE [@fadolalkarimPANDDEProvenancebasedANomaly2016]         | FS. ins.                                 | Custom VFS                                 |                                                             |
| URSprung [@rupprechtImprovingReproducibilityData2020]          | Audit, file-system ins.                  | auditd, IBM Spectrum Scale                 | Specific to IBM Spectrum Scale FS                           |
| Event Tracer for Windows [@EventTracingWin322021]              | Audit                                    | NT Kernel                                  | Implemented for Windows                                     |
| TREC [@vahdatTransparentResultCaching1998]                     | Audit                                    | Proc filesystem                            | Implemented for Solaris                                     |
| DTrace [@DTrace]                                               | Audit                                    | Respective kernels                         | Can do event processing in kernel-space                     |
| Sysmon [@markrussSysmonSysinternals2023]                       | Audit                                    | NT Kernel                                  | Implemented for Windows                                     |
| Ma et al. [@maAccurateLowCost2015]                             | Kernel ins.                              | ETW                                        |                                                             |
| BEEP [@leeHighAccuracyAttack2017]                              | Dyn., static binary ins.                 | Intel Pin, PEBIL                           |                                                             |
| libdft [@kemerlisLibdftPracticalDynamic2012]                   | Dyn. binary ins.                         | Intel Pin                                  |                                                             |
| RAIN [@jiRAINRefinableAttack2017]                              | kernel ins., lib. ins., dyn. binary ins. | libc ins., custom kernel module, Intel Pin | Records syscalls during runtime, replays offline under DIFT |
| DataTracker [@stamatogiannakisLookingBlackBoxCapturing2015]    | Dinamic binary ins.                      |                                            |                                                             |
| MPI[@maMPIMultiplePerspective2017]                             | Compile-time ins.                        | LLVM pass                                  | Requires manual input                                       |
| LDX [@kwonLDXCausalityInference2016]                           | Compile-time ins.                        | LLVM pass                                  |                                                             |
| S2Logger [@yiEvaluatingBenchmarkSubsetting2006a]               | Kernel ins.                              | Kernel module or Linux Security Module     |                                                             |
| ProTracer [@maProTracerPracticalProvenance2016]                | Kernel ins.                              | Linux tracepoints, custom kernel module    |                                                             |
| Hi-Fi [@pohlyHiFiCollectingHighfidelity2012]                   | Kernel ins.                              | Linux Security Module                      |                                                             |
| Lineage FS [@sarLineageFileSystem]                             | Kernel ins.                              | Modified kernel                            |                                                             |
| PASS/Pasta [@muniswamy-reddyProvenanceAwareStorageSystems2006] | Kernel ins., filesystem ins.             | Modified kernel, VFS                       |                                                             |
| PASSv2/Lasagna [@muniswamy-reddyLayeringProvenanceSystems2009] | Kernel ins., filesystem, lib. ins.       | Modified kernel, instrumented libc, VFS    |                                                             |
| RTAG [@jiEnablingRefinableCrossHost2018]                       | Kernel ins.                              | Modified kernel                            |                                                             |
| LPM/ProvMon [@batesTrustworthyWholeSystemProvenance2015]       | Kernel ins.                              | Modified kernel, kernel module, NetFilter  |                                                             |
| CamFlow [@pasquierPracticalWholesystemProvenance2017]          | Kernel ins.                              | Linux Security Module, NetFilter           |                                                             |
| LPROV [@wangLprovPracticalLibraryaware2018]                    | Kernel ins., library ins.                | Custom kernel module, custom loader, BEEP  |                                                             |
| Panorama [@yinPanoramaCapturingSystemwide2007]                 | VM ins.                                  | QEMU                                       |                                                             |
| PROV-Tracer [@stamatogiannakisDecouplingProvenanceCapture2015] | VM ins.                                  | QEMU, PANDA                                |                                                             |

: Provenance trackers mentioned in primary and secondary studies in our search results. {#tbl:tools}

[^spade]: SPADE can use multiple backends, including other provenance collectors. On Linux, SPADE can use: Auditd, CamFlow, FUSE; On MacOS: OpenBSM, MacFUSE, Fuse4x; On Windows: ProcessMonitor; On any platform: import static data (e.g., from logs on disk), applications instrumented with API, applications compiled with LLVM pass.

| Tool                                                  | Reason                                                          |
+-------------------------------------------------------+-----------------------------------------------------------------+
| ES3 [@frewES3DemonstrationTransparent2008]            | specific to ES3 platform                                        |
| Chimera [@fosterChimeraVirtualData2002]               | specific to Chimera platform                                    |
| INSPECTOR [@thalheimInspectorDataProvenance2016a]     | doesn't track files                                             |
| MCI [@jiEnablingRefinableCrossHost2018]               | offline; depends on online-LDX                                  |
| OmegaLog [@hassanOmegaLogHighFidelityAttack2020]      | depends on app-level logs                                       |
| LogGC [@leeLogGCGarbageCollecting2013]                | contribution is deleting irrelevant events in the logs          |
| UIScope [@yangUISCOPEAccurateInstrumentationfree2020] | captures UI interactions; uses ETW to capture I/O operations    |
| Winnower [@hassanScalableClusterAuditing2018]         | specific to Docker Swarm                                        |

: Excluded tools. {#tbl:excluded}

| Provenance publication                                   | Benchmarks                                                                                                                             | Comparisons          | Year |
|----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|----------------------|------|
| TREC [@vahdatTransparentResultCaching1998]               | open/close, compile Apache, compile LaTeX doc                                                                                          | Native               | 1999 |
| PASS [@muniswamy-reddyProvenanceAwareStorageSystems2006] | BLAST                                                                                                                                  | Native ext2          | 2006 |
| Panorama [@yinPanoramaCapturingSystemwide2007]           | curl, scp, gzip, bzip2                                                                                                                 | Native               | 2007 |
| PASSv2 [@muniswamy-reddyLayeringProvenanceSystems2009]   | BLAST, compile Linux, Postmark, Mercurial, Kepler[^p]                                                                                  | Native ext3, NFS     | 2009 |
| SPADEv2 [@gehaniSPADESupportProvenance2012]              | BLAST, compile Apache, Apache                                                                                                          | Native               | 2012 |
| Hi-Fi [@pohlyHiFiCollectingHighfidelity2012]             | lmbench, compile Linux, Postmark                                                                                                       | Native               | 2012 |
| libdft [@kemerlisLibdftPracticalDynamic2012]             | scp, {tar, gzip, bzip2} x {extract, compress}                                                                                          | PIN                  | 2012 |
| LogGC [@leeLogGCGarbageCollecting2013]                   | RUBiS, Firefox, MC[^p], Pidgin[^p], Pine[^p], Proftpd, Sendmail[^p], sshd, vim, w3m, wget, xpdf, yafc, Audacious, bash, Apache, mysqld | [^loggc-bench]       | 2013 |
| LPM/ProvMon [@batesTrustworthyWholeSystemProvenance2015] | lmbench, compile Linux, Postmark, BLAST                                                                                                | Native               | 2015 |
| Ma et al. [@maAccurateLowCost2015]                       | TextTransfer, Chromium, DrawTool, NetFTP, AdvancedFTP, Apache, IE, Paint, Notepad, Notepad++, simplehttp, Sublime Text                 | Native               | 2015 |
| ProTracer [@maProTracerPracticalProvenance2016]          | Apache, miniHTTP, ProFTPD, Vim[^p], Firefox, w3m, wget, mplayer[^p], Pine[^p], xpdf[^p], MC[^p], yafc                                  | Auditd, BEEP, LogGC  | 2016 |
| LDX [@kwonLDXCausalityInference2016]                     | SPEC CPU 2006, Firefox, lynx[^p], nginx, tnftp, sysstat, gif2png, mp3info, prozilla                                                    | Native               | 2016 |
| (LDX continued)                                          | yopsweb[^p], ngircd[^p], gocr, Apache, pbzip2, pigz, axel, x264                                                                        |                      |      |
| MPI [@maMPIMultiplePerspective2017]                      | Apache, bash, Evince[^p], Firefox, Krusader[^p], wget, most[^p], MC[^p], mplayer[^p],                                                  | Audit, LPM-HiFi      | 2017 |
| (MPI continued)                                          | MPV[^p], nano[^p], Pine[^p], ProFTPd, SKOD, TinyHTTPd, Transmission[^p], Vim[^p], w3m, Xpdf[^p], Yafc                                  |                      |      |
| CamFlow [@pasquierPracticalWholesystemProvenance2017]    | lmbench, postmark, unpack kernel, compile Linux, Apache, Memcache, redis, php, pybench                                                 | Native               | 2017 |
| BEEP [@leeHighAccuracyAttack2017]                        | Apache, Vim, Firefox, wget, Cherokee, w3m, ProFTPd, yafc, Transmission[^p], Pine[^p], bash, MC[^p], sshd, sendmail[^p]                 | Native               | 2017 |
| RAIN [@jiRAINRefinableAttack2017]                        | SPEC CPU 2006, cp linux, wget, compile libc, Firefox, SPLASH-3                                                                         | Native               | 2017 |
| Sciunit [@tonthatSciunitsReusableResearch2017]           | VIC, FIE                                                                                                                               | Native               | 2017 |
| LPROV [@wangLprovPracticalLibraryaware2018]              | Apache, simplehttp, proftpd, sshd, firefox, filezilla, lynx, links, w3m, wget, ssh, pine, vim, emacs, xpdf                             | Native               | 2018 |
| MCI [@kwonMCIModelingbasedCausality2018]                 | Firefox, Apache, Lighttpd, nginx, ProFTPd, CUPS[^p], vim[^p], elinks[^p],                                                              | BEEP                 | 2018 |
| (MCI continued)                                          | alpine[^p], zip, transmission[^p], lftp, yafc, wget, ping, procps                                                                      |                      |      |
| RTAG [@jiEnablingRefinableCrossHost2018]                 | SPEC CPU 2006, scp, wget, compile llvm, Apache                                                                                         | RAIN                 | 2018 |
| URSPRING [@rupprechtImprovingReproducibilityData2020]    | open/close, fork/exec/exit, pipe/dup/close, socket/connect, CleanML, Vanderbilt[^p], Spark, ImageML[^p]                                | Native, SPADE+auditd | 2020 |

: Benchmarks used in various provenance publications. {#tbl:prior-benchmarks}

[^p]: Not enough information to reconstruct this benchmark (unsure what executable or missing workload with no obvious substitute).

[^loggc]: LogGC measures the offline running time and size of garbage collected logs; there is no comparison to native would be applicable.

| Benchmark group                                                                                     | Uses in prior work |
|-----------------------------------------------------------------------------------------------------|--------------------|
| BLAST                                                                                               | 4                  |
| Python data science                                                                                 | 0                  |
| HTTP server/traffic (Apache httpd, miniHTTP, simplehttp, lighttpd, Nginx, tinyhttpd, cherokee)      | 10                 |
| HTTP serer/client (curl, wget, prozilla, axel)                                                      | 9                  |
| FTP server/traffic (ProFTPd)                                                                        | 5                  |
| FTP client (lftp, yafc, tnftp, skod)                                                                | 2                  |
| SPEC CPU 2006                                                                                       | 3                  |
| Compile (Apache, LLVM, libc, Linux, LaTeX doc)                                                      | 8                  |
| lmbench[^lmbench]                                                                                   | 5                  |
| Postmark                                                                                            | 4                  |
| SPLASH-3                                                                                            | 1                  |
| Browsers (Firefox, Chromium, w3m)                                                                   | 8                  |
| VCS (Mercurial, git)                                                                                | 1                  |
| Un/archive ({compress, decompress} x tar x {nothing, bzip2, pbzip, gzip, pigz, zip})[^unpack-linux] | 5                  |
| Shellbench (bash, sh)                                                                               | 3                  |
| Workflows (Snakemake-workflow-catalog, Nf-core, CleanML, Spark, VIC, FIE)                           | 2                  |
| Microbenchmarks (open/close, fork/exec, pipe/dup/close, socket/connect)                             | 2                  |
| xSDK codes                                                                                          | 0                  |
| Small, fast binaries (procps, sysstat, gif2png, mp3info, gocr)                                      | 2                  |
| x264                                                                                                | 1                  |

: Benchmarks implemented by this work {#tbl:implemented-benchmarks}

[^unpack-linux]: We count "unpack linux" as an occurrence of an un/archive benchmark.
[^lmbench]: Noting that lmbench contains open/close, fork/exec, and pipe/close.

### Benchmarks

### Quantitative performance comparison

### Predictive model

## Analysis

### Threats to validity

## Future work

## Conclusion
